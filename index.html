<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>小凡的耿</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="小凡的耿的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="小凡的耿">
<meta property="og:url" content="https://github.com/lhw0828/lhw0828.github.io.git/index.html">
<meta property="og:site_name" content="小凡的耿">
<meta property="og:description" content="小凡的耿的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="lhw">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/lhw0828/lhw0828.github.io.git/atom.xml" title="小凡的耿" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/lhw0828/lhw0828.github.io.git/favicon.png">
  
  
  
<link rel="stylesheet" href="/lhw0828/lhw0828.github.io.git/css/style.css">

  
    
<link rel="stylesheet" href="/lhw0828/lhw0828.github.io.git/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/lhw0828/lhw0828.github.io.git/" id="logo">小凡的耿</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/lhw0828/lhw0828.github.io.git/" id="subtitle">小凡的耿的个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/lhw0828/lhw0828.github.io.git/">Home</a>
        
          <a class="main-nav-link" href="/lhw0828/lhw0828.github.io.git/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/lhw0828/lhw0828.github.io.git/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/lhw0828/lhw0828.github.io.git"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/lhw0828/lhw0828.github.io.git/2024/07/06/test/" class="article-date">
  <time class="dt-published" datetime="2024-07-06T02:37:28.000Z" itemprop="datePublished">2024-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/lhw0828/lhw0828.github.io.git/2024/07/06/test/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-Redis项目中的场景"><a href="#1-Redis项目中的场景" class="headerlink" title="1. Redis项目中的场景"></a>1. Redis项目中的场景</h2><ul>
<li>缓存</li>
<li>分布式锁</li>
</ul>
<h2 id="2-如果发生缓存穿透、击穿、雪崩，该如何解决"><a href="#2-如果发生缓存穿透、击穿、雪崩，该如何解决" class="headerlink" title="2. 如果发生缓存穿透、击穿、雪崩，该如何解决"></a>2. 如果发生缓存穿透、击穿、雪崩，该如何解决</h2><p>缓存穿透：查询一个不存在的数据，mysql查询不到数据也不会直接写入到缓存，导致每次请求都会查数据库</p>
<p>解决方案：</p>
<ul>
<li><p>缓存空数据，查询返回的数据为空，仍把这空结果进行缓存</p>
<ul>
<li>优点：简单</li>
<li>缺点：消耗内存，可能会发生不一致的问题（设置短期过期时间）</li>
</ul>
</li>
<li><p>布隆过滤器</p>
<ul>
<li>优点：内存占用少，没有多余的key</li>
<li>缺点：实现复杂，存在误判</li>
</ul>
<p>  布隆过滤器是由一个位数组（bitmap）和一组哈希函数组成</p>
<ul>
<li>位数组：初始时，所有位都为0，每个元素经过多次哈希函数处理后设为1</li>
<li>误判率：数组大小决定，数组小误判率大，反之。</li>
</ul>
</li>
</ul>
<p>缓存击穿：给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮</p>
<p>解决方案：</p>
<ul>
<li><p>互斥锁</p>
<p>  当缓存失效时，不立即去load db，先使用setnx设置一个互斥锁，当操作成功返回后再进行load db的操作并回设缓存，否则重试get缓存的方法</p>
</li>
<li><p>逻辑过期</p>
<p>  设置key时，设置一个过期时间字段存入缓存中，不给当前key设置过期时间；当查询的时候，从redis取出数据后判断时间是否过期；如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，但这个数据不是最新的</p>
</li>
</ul>
<p>缓存雪崩：指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的key的TTL添加随机值</li>
</ul>
<h2 id="3-双写一致性（redis与mysql如何同步）"><a href="#3-双写一致性（redis与mysql如何同步）" class="headerlink" title="3. 双写一致性（redis与mysql如何同步）"></a>3. 双写一致性（redis与mysql如何同步）</h2><p>缓存中的语义结果要跟实际的语义结果保持强一致性</p>
<p>双写一致性：当修改了数据的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</li>
<li>写操作：延时双删</li>
</ul>
<p>我们采用的时redission实现的读写锁，在读的时候添加共享锁，保证读读不互斥。当我们更新数据的时候，添加互斥锁；这样就保证在写时候不会让其他线程读数据。这里面的读方法和写方法都是同一把锁</p>
<p>延时双删：在写操作时，先删去缓存中的数据，然后更新数据库，最后再延时删除缓存中的数据，但这个延时时间不太好确定，在延时时候会出现脏数据，并不能保证强一致性。</p>
<p>保证可用性：采用阿里的canal组件实现数据同步；不需要更改业务代码，部署一个canal服务。然后canel会伪装成一个mysql的从节点；当mysql数据更新后，canal会读取binlog的数据，然后再通过canal的客户端获取到数据，更新缓存就可以了。</p>
<h2 id="4-redis的数据持久化"><a href="#4-redis的数据持久化" class="headerlink" title="4. redis的数据持久化"></a>4. redis的数据持久化</h2><ul>
<li><p>RDB：Redis的数据快照，将内存中的所有数据都记录到磁盘中</p>
<p>  bgsave：redis.conf</p>
<p>  bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。fork采用的时copy-on-write技术，当主进程执行读操作时，则访问共享内存；当主进程执行写操作时，则会拷贝一份数据，执行写操作。</p>
</li>
<li><p>AOF：追加文件。redis每一个写命令都会记录在AOF文件中（采用everysec）</p>
<p>  bgrewriteaof命令，可以让AOF文件执行重写功能</p>
</li>
</ul>
<h2 id="5-redis的数据过期策略（删除策略）"><a href="#5-redis的数据过期策略（删除策略）" class="headerlink" title="5. redis的数据过期策略（删除策略）"></a>5. redis的数据过期策略（删除策略）</h2><p><strong>惰性删除，定期删除</strong></p>
<p><strong>惰性删除</strong>：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p>
<p><strong>定期删除</strong>：每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)</p>
<ul>
<li>定时任务：执行频率默认未为10hz，每次不超过25ms</li>
<li>fast模式：执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ul>
<p>Redis的过期删除策略：惰性删除+定期删除</p>
<h2 id="6-假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）"><a href="#6-假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）" class="headerlink" title="6. 假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）"></a>6. 假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）</h2><p><strong>数据的淘汰策略</strong>：当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p>
<p>redis提供了多种数据淘汰策略，默认是noeviction，不删除任何数据，内部不足直接报错。</p>
<p>LRU：最近最少使用，当前时间减去最后一次的访问时间</p>
<p>LFU：最近最少频率使用，会统计每个key的访问频率</p>
<p>我们在项目中设置的时allkeys-lru，挑选最近最少使用的数据淘汰，保证热点数据</p>
<h2 id="7-redis分布式锁，是如何实现的？"><a href="#7-redis分布式锁，是如何实现的？" class="headerlink" title="7. redis分布式锁，是如何实现的？"></a>7. redis分布式锁，是如何实现的？</h2><p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令。setnx是SET if not exists(如果不存在，则 SET)的简写。</p>
<p>由于redis是单线程的，用了命令后，只能由一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端不能设置这个key的。（redisson+lua脚本）</p>
<p>redis实现分布式锁的有效时长是采用redis的一个框架redisson实现的。在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务没有执行完成的时候，在redisson里面引入了一个看门狗机制，每隔一段时间检查当前业务是否还持有锁，如果持有就增加锁的持有时间，当业务完成之后释放锁</p>
<h2 id="7-redis集群有哪些"><a href="#7-redis集群有哪些" class="headerlink" title="7. redis集群有哪些"></a>7. redis集群有哪些</h2><ul>
<li><p>主从复制</p>
<p>  单节点的redis的并发能力是有限的，为了提高并发能力就需要搭建主从集群，实现读写分离</p>
<p>  主从同步原理：</p>
<ul>
<li>全量同步<ol>
<li>从节点请求主节点同步数据（replication id、 offset ）</li>
<li>主节点判断是否是第一次请求，是第一次就与从节点同步版本信息（replication id和offset）</li>
<li>主节点执行bgsave，生成rdb文件后，发送给从节点去执行</li>
<li>在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）</li>
<li>把生成之后的命令日志文件发送给从节点进行同步</li>
</ol>
</li>
<li>增量同步<ol>
<li>从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值</li>
<li>主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</li>
</ol>
</li>
</ul>
</li>
<li><p>哨兵模式</p>
<p>  Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。作用如下</p>
<ul>
<li><p>监控：sentinel会检查master和slave是否按预期工作</p>
<p>  sentinel会基于心跳机制检测服务状态，每个1秒向集群的每个实例发送ping命令</p>
<p>  主观下线： 如果某个sentinel节点发现某实例未在规定时间内响应，则认为该实例<strong>主观下线</strong></p>
<p>  客观下线： 若超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线</p>
</li>
<li><p>通知：sentinel充当redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给redis客户端</p>
</li>
<li><p>自动故障恢复：如果master故障，sentinel会将一个slave提升为master。当故障实例恢复后也以薪的master为主</p>
</li>
</ul>
</li>
</ul>
<p><strong>哨兵选主规则</strong></p>
<ol>
<li>判断主从节点断开时间长短，如超过指定值就排除该从节点</li>
<li>判断从节点的slave-priority值，越小优先级越高</li>
<li>判断slave节点的offset值，越大优先级越高</li>
<li>判断slave的id大小</li>
</ol>
<p><strong>redis集群的脑裂问题</strong></p>
<p>集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失</p>
<p><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p>
<ul>
<li>分片集群</li>
</ul>
<h2 id="8-Redis是单线程的，但是为什么还那么快"><a href="#8-Redis是单线程的，但是为什么还那么快" class="headerlink" title="8. Redis是单线程的，但是为什么还那么快"></a>8. Redis是单线程的，但是为什么还那么快</h2><ul>
<li>Redis是纯内存操作，执行速度非常快</li>
<li>采用单线程，避免不必要的上下文切换可竞争条件</li>
<li>使用I&#x2F;O多路复用模型，非阻塞IO</li>
</ul>
<p>能解释一下I&#x2F;O多路复用模型？</p>
<p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度， I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p>
<p><strong>IO多路复用</strong>：是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听Socket的方式、通知的方式又有多种实现，常见的有：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>2.<strong>Redis网络模型</strong></p>
<p>就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<ul>
<li>连接应答处理器</li>
<li>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</li>
<li>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/lhw0828/lhw0828.github.io.git/2024/07/06/test/" data-id="cly9p1mam0000voaaf04tey2d" data-title="Redis" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/lhw0828/lhw0828.github.io.git/tags/Java%E9%9D%A2%E8%AF%95/" rel="tag">Java面试</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/lhw0828/lhw0828.github.io.git/tags/Java%E9%9D%A2%E8%AF%95/" rel="tag">Java面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/lhw0828/lhw0828.github.io.git/tags/Java%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Java面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/lhw0828/lhw0828.github.io.git/archives/2024/07/">July 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/lhw0828/lhw0828.github.io.git/2024/07/06/test/">Redis</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 lhw<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/lhw0828/lhw0828.github.io.git/" class="mobile-nav-link">Home</a>
  
    <a href="/lhw0828/lhw0828.github.io.git/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/lhw0828/lhw0828.github.io.git/js/jquery-3.6.4.min.js"></script>



  
<script src="/lhw0828/lhw0828.github.io.git/fancybox/jquery.fancybox.min.js"></script>




<script src="/lhw0828/lhw0828.github.io.git/js/script.js"></script>





  </div>
</body>
</html>